use std::path::PathBuf;

/// Path where the git shim is installed.
pub fn shim_path() -> Option<PathBuf> {
    dirs::home_dir().map(|h| h.join(".blameprompt").join("bin").join("git"))
}

/// Check if the git shim is currently installed.
#[allow(dead_code)]
pub fn is_installed() -> bool {
    shim_path().is_some_and(|p| p.exists())
}

/// Content of the transparent git wrapper script.
fn shim_content(binary: &str) -> String {
    format!(
        r#"#!/bin/sh
# BlamePrompt transparent git wrapper
# Automatically attaches AI receipts after commits and pushes notes to remotes.
# Generated by: blameprompt install-git-wrap

# Augment PATH so blameprompt is found even in GUI git clients
export PATH="$HOME/.cargo/bin:$HOME/.local/bin:/opt/homebrew/bin:/usr/local/bin:$PATH"

# Find the real git binary (exclude this shim's directory to avoid infinite loop)
_BP_BIN_DIR="$(dirname "$0")"
REAL_GIT=$(PATH=$(printf '%s' "$PATH" | tr ':' '\n' | grep -v "$HOME/.blameprompt/bin" | grep -v "$_BP_BIN_DIR" | tr '\n' ':' | sed 's/:$//') which git 2>/dev/null)
if [ -z "$REAL_GIT" ]; then
    # Fallback to well-known locations
    for _p in /usr/bin/git /usr/local/bin/git /opt/homebrew/bin/git; do
        if [ -x "$_p" ]; then
            REAL_GIT="$_p"
            break
        fi
    done
fi
[ -z "$REAL_GIT" ] && {{ echo "blameprompt git-wrap: cannot find real git" >&2; exit 1; }}

BLAMEPROMPT="{binary}"
[ -x "$BLAMEPROMPT" ] || BLAMEPROMPT="blameprompt"

# Run the real git command
"$REAL_GIT" "$@"
_EXIT=$?

# Post-process specific commands
if [ $_EXIT -eq 0 ]; then
    case "$1" in
        commit)
            # Auto-attach staged AI receipts to the new commit
            "$BLAMEPROMPT" attach 2>/dev/null || true
            ;;
        push)
            # Auto-push AI notes to the same remote
            _REMOTE="${{2:-origin}}"
            "$REAL_GIT" push "$_REMOTE" refs/notes/blameprompt 2>/dev/null || true
            ;;
    esac
fi

exit $_EXIT
"#,
        binary = binary
    )
}

/// Install the transparent git wrapper shim into ~/.blameprompt/bin/git.
pub fn install() -> Result<PathBuf, String> {
    let shim = shim_path().ok_or("Cannot determine home directory")?;

    if let Some(parent) = shim.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Cannot create ~/.blameprompt/bin/: {}", e))?;
    }

    let binary = super::hooks::resolve_binary_path();
    let content = shim_content(&binary);

    std::fs::write(&shim, &content).map_err(|e| format!("Cannot write git shim: {}", e))?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        std::fs::set_permissions(&shim, std::fs::Permissions::from_mode(0o755))
            .map_err(|e| format!("Cannot chmod git shim: {}", e))?;
    }

    // Inject PATH export into common shell RC files (idempotent)
    inject_path_into_shell_rc();

    Ok(shim)
}

/// Uninstall the git shim.
#[allow(dead_code)]
pub fn uninstall() -> Result<(), String> {
    let shim = shim_path().ok_or("Cannot determine home directory")?;
    if shim.exists() {
        std::fs::remove_file(&shim).map_err(|e| format!("Cannot remove git shim: {}", e))?;
    }
    Ok(())
}

/// Append `export PATH="$HOME/.blameprompt/bin:$PATH"` to the first found shell RC file
/// that doesn't already contain it.
fn inject_path_into_shell_rc() {
    let home = match dirs::home_dir() {
        Some(h) => h,
        None => return,
    };

    let path_export = "\n# BlamePrompt git wrapper â€” transparent AI receipt tracking\nexport PATH=\"$HOME/.blameprompt/bin:$PATH\"\n";

    // Try RC files in preference order
    for rc_name in &[".zshrc", ".bashrc", ".bash_profile", ".profile"] {
        let rc_path = home.join(rc_name);
        if rc_path.exists() {
            let content = std::fs::read_to_string(&rc_path).unwrap_or_default();
            if content.contains(".blameprompt/bin") {
                // Already injected (or user set it up manually)
                return;
            }
            let _ = {
                use std::io::Write;
                std::fs::OpenOptions::new()
                    .append(true)
                    .open(&rc_path)
                    .and_then(|mut f| f.write_all(path_export.as_bytes()))
            };
            return; // Only patch the first found RC file
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shim_content_contains_key_logic() {
        let content = shim_content("/usr/local/bin/blameprompt");
        assert!(content.contains("REAL_GIT"), "should define REAL_GIT");
        assert!(
            content.contains(".blameprompt/bin"),
            "should skip own bin dir"
        );
        assert!(content.contains("attach"), "should run attach after commit");
        assert!(
            content.contains("refs/notes/blameprompt"),
            "should push notes after push"
        );
        assert!(
            content.contains("/usr/local/bin/blameprompt"),
            "should embed binary path"
        );
        assert!(
            content.contains("BLAMEPROMPT="),
            "should set BLAMEPROMPT variable"
        );
    }
}

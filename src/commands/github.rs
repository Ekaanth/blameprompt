/// GitHub PR comment integration.
///
/// Posts an AI attribution summary as a pull request comment using the GitHub API.
/// Uses curl (no reqwest/ureq dependency) to match the existing HTTP pattern.
use crate::core::util;
use crate::git::notes::list_commits_with_notes;
use crate::git::notes::read_receipts_for_commit;
use std::process::Command;

/// Post an AI attribution summary as a GitHub PR comment.
///
/// `pr_number` — override the auto-detected PR number.
/// `repo` — override the "owner/repo" (default: detected from `git remote get-url origin`).
pub fn run(pr_number: Option<u32>, repo: Option<&str>) {
    let token = match std::env::var("GITHUB_TOKEN").ok() {
        Some(t) if !t.is_empty() => t,
        _ => {
            eprintln!("[blameprompt] GITHUB_TOKEN env var not set. Export it and retry.");
            std::process::exit(1);
        }
    };

    let repo_slug = match repo {
        Some(r) => r.to_string(),
        None => match detect_repo_slug() {
            Some(r) => r,
            None => {
                eprintln!("[blameprompt] Cannot detect GitHub repo. Pass --repo owner/repo.");
                std::process::exit(1);
            }
        },
    };

    let pr = match pr_number {
        Some(n) => n,
        None => match find_pr_for_current_branch(&repo_slug, &token) {
            Some(n) => n,
            None => {
                eprintln!("[blameprompt] Cannot find open PR for this branch. Pass --pr <number>.");
                std::process::exit(1);
            }
        },
    };

    let body = generate_pr_body();
    match post_pr_comment(&repo_slug, pr, &body, &token) {
        Ok(url) => println!("[blameprompt] PR comment posted: {}", url),
        Err(e) => {
            eprintln!("[blameprompt] Failed to post PR comment: {}", e);
            std::process::exit(1);
        }
    }
}

/// Generate a Markdown body summarizing AI receipts for commits in the current branch.
fn generate_pr_body() -> String {
    let commits = list_commits_with_notes();
    if commits.is_empty() {
        return "<!-- blameprompt -->\n**No AI receipts found** for this branch.\n".to_string();
    }

    let mut md = String::from("<!-- blameprompt -->\n## AI Code Attribution\n\n");
    md.push_str(
        "Generated by [blameprompt](https://github.com/metaquity/blameprompt) \u{1f916}\n\n",
    );
    md.push_str("| Commit | Model | Prompt | Files | Lines Added |\n");
    md.push_str("|--------|-------|--------|-------|-------------|\n");

    let mut total_receipts = 0u32;
    let mut total_lines = 0u32;

    for sha in &commits {
        let short = util::short_sha(sha);
        if let Some(payload) = read_receipts_for_commit(sha) {
            for receipt in &payload.receipts {
                let files = receipt.files_changed.len();
                let lines = receipt.effective_total_additions();
                let summary = receipt.prompt_summary.chars().take(60).collect::<String>();
                let summary = if receipt.prompt_summary.len() > 60 {
                    format!("{}…", summary)
                } else {
                    summary
                };
                md.push_str(&format!(
                    "| `{}` | {} | {} | {} | {} |\n",
                    short, receipt.model, summary, files, lines,
                ));
                total_receipts += 1;
                total_lines += lines;
            }
        }
    }

    md.push('\n');
    md.push_str(&format!(
        "**Total**: {} receipt(s) · {} AI-generated lines\n",
        total_receipts, total_lines
    ));

    md
}

/// Post a comment to a GitHub PR via curl.
fn post_pr_comment(repo: &str, pr: u32, body: &str, token: &str) -> Result<String, String> {
    // Escape body for JSON: replace backslash, double-quote, and newlines
    let escaped = body
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r");

    let json_body = format!(r#"{{"body":"{}"}}"#, escaped);
    let url = format!(
        "https://api.github.com/repos/{}/issues/{}/comments",
        repo, pr
    );

    let output = Command::new("curl")
        .args([
            "-s",
            "-w",
            "\n%{http_code}",
            "-X",
            "POST",
            "-H",
            "Accept: application/vnd.github+json",
            "-H",
            &format!("Authorization: Bearer {}", token),
            "-H",
            "X-GitHub-Api-Version: 2022-11-28",
            "-H",
            "Content-Type: application/json",
            "-d",
            &json_body,
            &url,
        ])
        .output()
        .map_err(|e| format!("curl failed: {}", e))?;

    let raw = String::from_utf8_lossy(&output.stdout);
    let (response_body, status_code) = split_curl_response(&raw);

    if status_code == 201 {
        // Extract the html_url from the response
        let comment_url =
            extract_json_string(response_body, "html_url").unwrap_or_else(|| url.clone());
        Ok(comment_url)
    } else {
        Err(format!(
            "GitHub API returned HTTP {} — {}",
            status_code,
            response_body.chars().take(200).collect::<String>()
        ))
    }
}

/// Detect "owner/repo" from `git remote get-url origin`.
fn detect_repo_slug() -> Option<String> {
    let output = Command::new("git")
        .args(["remote", "get-url", "origin"])
        .output()
        .ok()?;

    if !output.status.success() {
        return None;
    }

    let url = String::from_utf8_lossy(&output.stdout).trim().to_string();
    parse_github_slug(&url)
}

/// Parse "owner/repo" from SSH or HTTPS GitHub remote URL.
fn parse_github_slug(url: &str) -> Option<String> {
    // SSH: git@github.com:owner/repo.git
    if let Some(rest) = url.strip_prefix("git@github.com:") {
        return Some(rest.trim_end_matches(".git").to_string());
    }
    // HTTPS: https://github.com/owner/repo.git
    if let Some(rest) = url.strip_prefix("https://github.com/") {
        return Some(rest.trim_end_matches(".git").to_string());
    }
    None
}

/// Find the open PR number for the current branch using the GitHub API.
fn find_pr_for_current_branch(repo: &str, token: &str) -> Option<u32> {
    let branch = current_branch()?;
    let url = format!(
        "https://api.github.com/repos/{}/pulls?state=open&head={}:{}&per_page=1",
        repo,
        // We need the owner for the head filter
        repo.split('/').next().unwrap_or(""),
        branch
    );

    let output = Command::new("curl")
        .args([
            "-s",
            "-w",
            "\n%{http_code}",
            "-H",
            "Accept: application/vnd.github+json",
            "-H",
            &format!("Authorization: Bearer {}", token),
            "-H",
            "X-GitHub-Api-Version: 2022-11-28",
            &url,
        ])
        .output()
        .ok()?;

    let raw = String::from_utf8_lossy(&output.stdout);
    let (body, status_code) = split_curl_response(&raw);

    if status_code != 200 {
        return None;
    }

    // Parse JSON array, grab first element's "number" field
    extract_first_pr_number(body)
}

fn current_branch() -> Option<String> {
    let output = Command::new("git")
        .args(["rev-parse", "--abbrev-ref", "HEAD"])
        .output()
        .ok()?;
    if output.status.success() {
        let b = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if b != "HEAD" {
            Some(b)
        } else {
            None
        }
    } else {
        None
    }
}

/// Split curl response with `-w "\n%{http_code}"` suffix.
fn split_curl_response(raw: &str) -> (&str, u32) {
    if let Some(pos) = raw.rfind('\n') {
        let status_str = raw[pos + 1..].trim();
        let status: u32 = status_str.parse().unwrap_or(0);
        (&raw[..pos], status)
    } else {
        (raw, 0)
    }
}

/// Extract a string value from a flat JSON object by key (no full JSON parser needed).
fn extract_json_string(json: &str, key: &str) -> Option<String> {
    let needle = format!("\"{}\":", key);
    let start = json.find(&needle)?;
    let after_colon = json[start + needle.len()..].trim_start();
    if let Some(inner) = after_colon.strip_prefix('"') {
        let end = inner.find('"')?;
        Some(inner[..end].to_string())
    } else {
        None
    }
}

/// Extract the PR number from a GitHub API list response (JSON array).
fn extract_first_pr_number(json: &str) -> Option<u32> {
    // Look for `"number": <N>` in the first PR object
    let needle = "\"number\":";
    let start = json.find(needle)?;
    let after = json[start + needle.len()..].trim_start();
    let end = after.find(|c: char| !c.is_ascii_digit())?;
    after[..end].parse().ok()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_github_slug_ssh() {
        assert_eq!(
            parse_github_slug("git@github.com:metaquity/blameprompt.git"),
            Some("metaquity/blameprompt".to_string())
        );
    }

    #[test]
    fn test_parse_github_slug_https() {
        assert_eq!(
            parse_github_slug("https://github.com/metaquity/blameprompt.git"),
            Some("metaquity/blameprompt".to_string())
        );
    }

    #[test]
    fn test_parse_github_slug_no_match() {
        assert_eq!(parse_github_slug("https://gitlab.com/foo/bar.git"), None);
    }

    #[test]
    fn test_extract_json_string() {
        let json = r#"{"html_url":"https://example.com","id":123}"#;
        assert_eq!(
            extract_json_string(json, "html_url"),
            Some("https://example.com".to_string())
        );
    }

    #[test]
    fn test_extract_first_pr_number() {
        let json = r#"[{"number": 42,"title":"fix stuff"}]"#;
        assert_eq!(extract_first_pr_number(json), Some(42));
    }

    #[test]
    fn test_split_curl_response() {
        let raw = "{\"id\":1}\n201";
        let (body, status) = split_curl_response(raw);
        assert_eq!(body, "{\"id\":1}");
        assert_eq!(status, 201);
    }
}
